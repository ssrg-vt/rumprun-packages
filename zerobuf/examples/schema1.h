// Generated by zerobufCxx.py

#pragma once
#include <zerobuf/ConstAllocator.h> // static create
#include <zerobuf/Vector.h> // member
#include <zerobuf/Zerobuf.h> // base class
#include <array> // member
#include <memory> // std::unique_ptr


class KeyValue;
typedef std::unique_ptr< const KeyValue > ConstKeyValuePtr;

class KeyValue : public ::zerobuf::Zerobuf
{
public:
    int32_t getIntvalue() const;
    /**
     * Set the Intvalue value.
     * notifyChanged() is internally called after the change has been done.
     * 
     * @param value the Intvalue value
     **/
    void setIntvalue( int32_t value );

    double getDoublevalue() const;
    /**
     * Set the Doublevalue value.
     * notifyChanged() is internally called after the change has been done.
     * 
     * @param value the Doublevalue value
     **/
    void setDoublevalue( double value );

    KeyValue();
    KeyValue( const int32_t& intvalueValue, const double& doublevalueValue );
    KeyValue( const KeyValue& rhs );
    KeyValue( KeyValue&& rhs ) noexcept;
    KeyValue( const ::zerobuf::Zerobuf& rhs );
    explicit KeyValue( ::zerobuf::AllocatorPtr allocator );
    virtual ~KeyValue();
    KeyValue& operator = ( const KeyValue& rhs ) { ::zerobuf::Zerobuf::operator = ( rhs ); return *this; }
    KeyValue& operator = ( KeyValue&& rhs );

    // Introspection
    std::string getSchema() const final;
    static std::string ZEROBUF_SCHEMA();
    std::string getTypeName() const final { return "KeyValue"; }
    static std::string ZEROBUF_TYPE_NAME() { return "KeyValue"; }
    ::zerobuf::uint128_t getTypeIdentifier() const final { return ::zerobuf::uint128_t( 0xb4b0c39847a4b2dfull, 0x869b23418201dbf9ull ); }
    static ::zerobuf::uint128_t ZEROBUF_TYPE_IDENTIFIER() { return ::zerobuf::uint128_t( 0xb4b0c39847a4b2dfull, 0x869b23418201dbf9ull ); }
    size_t getZerobufStaticSize() const final { return 16; }
    static size_t ZEROBUF_STATIC_SIZE() { return 16; }
    size_t getZerobufNumDynamics() const final { return 0; }
    static size_t ZEROBUF_NUM_DYNAMICS() { return 0; }
    static ConstKeyValuePtr create( const void* data, const size_t size ) { return ConstKeyValuePtr( new KeyValue( ::zerobuf::AllocatorPtr( new ::zerobuf::ConstAllocator( reinterpret_cast< const uint8_t* >( data ), size )))); }

    void _parseJSON( const Json::Value& json ) final;
    void _createJSON( Json::Value& json ) const final;
};

namespace zerobuf
{
}

