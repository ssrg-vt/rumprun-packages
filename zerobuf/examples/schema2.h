// Generated by zerobufCxx.py

#pragma once
#include <zerobuf/ConstAllocator.h> // static create
#include <zerobuf/Vector.h> // member
#include <zerobuf/Zerobuf.h> // base class
#include <array> // member
#include <memory> // std::unique_ptr


class DoubleTable;
typedef std::unique_ptr< const DoubleTable > ConstDoubleTablePtr;

class DoubleTable : public ::zerobuf::Zerobuf
{
public:
    /**
     * Get a pointer to the Doublearray fixed size array.
     * @warning: If the pointer is used to modify the object, notifyChanged() needs to be explicitly called afterwards.
     * 
     * @return a pointer to the Doublearray fixed size array object (double*).
     **/
    double* getDoublearray();
    const double* getDoublearray() const;
    std::vector< double > getDoublearrayVector() const;
    /**
     * Set the value of the Doublearray fixed size array from a double*.
     * notifyChanged() is internally called after the data has been copied.
     * 
     * @param value a 125-length double array with the data to be set
     **/
    void setDoublearray( double value[ 125 ] );
    /**
     * Set the value of the Doublearray fixed size array object from a std::vector< double >.
     * notifyChanged() is internally called after the change has been done.
     * 
     * @param value a std::vector< double > with the data to be set
     **/
    void setDoublearray( const std::vector< double >& value );
    size_t getDoublearraySize() const;

    DoubleTable();
    DoubleTable( const std::vector< double >& doublearrayValue );
    DoubleTable( const DoubleTable& rhs );
    DoubleTable( DoubleTable&& rhs ) noexcept;
    DoubleTable( const ::zerobuf::Zerobuf& rhs );
    explicit DoubleTable( ::zerobuf::AllocatorPtr allocator );
    virtual ~DoubleTable();
    DoubleTable& operator = ( const DoubleTable& rhs ) { ::zerobuf::Zerobuf::operator = ( rhs ); return *this; }
    DoubleTable& operator = ( DoubleTable&& rhs );

    // Introspection
    std::string getSchema() const final;
    static std::string ZEROBUF_SCHEMA();
    std::string getTypeName() const final { return "DoubleTable"; }
    static std::string ZEROBUF_TYPE_NAME() { return "DoubleTable"; }
    ::zerobuf::uint128_t getTypeIdentifier() const final { return ::zerobuf::uint128_t( 0x8074f5247cc6a154ull, 0x76f658b96b3c665dull ); }
    static ::zerobuf::uint128_t ZEROBUF_TYPE_IDENTIFIER() { return ::zerobuf::uint128_t( 0x8074f5247cc6a154ull, 0x76f658b96b3c665dull ); }
    size_t getZerobufStaticSize() const final { return 1004; }
    static size_t ZEROBUF_STATIC_SIZE() { return 1004; }
    size_t getZerobufNumDynamics() const final { return 0; }
    static size_t ZEROBUF_NUM_DYNAMICS() { return 0; }
    static ConstDoubleTablePtr create( const void* data, const size_t size ) { return ConstDoubleTablePtr( new DoubleTable( ::zerobuf::AllocatorPtr( new ::zerobuf::ConstAllocator( reinterpret_cast< const uint8_t* >( data ), size )))); }

    void _parseJSON( const Json::Value& json ) final;
    void _createJSON( Json::Value& json ) const final;
};

namespace zerobuf
{
}

